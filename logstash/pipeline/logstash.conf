input {
  file {
    id => "nginx_access"
    path => ["/logs/access.log"]
    start_position => "beginning"
    sincedb_path => "/usr/share/logstash/data/sincedb_access"
    mode => "tail"
    tags => ["nginx_access"]
  }
  file {
    id => "nginx_error"
    path => ["/logs/error.log"]
    start_position => "beginning"
    sincedb_path => "/usr/share/logstash/data/sincedb_error"
    mode => "tail"
    tags => ["nginx_error"]
  }
}

filter {
  if "nginx_access" in [tags] {
    grok {
      match => { "message" => [
        '%{IPORHOST:clientip} %{DATA:ident} %{DATA:auth} \[%{HTTPDATE:timestamp}\] "%{WORD:verb} %{DATA:request} HTTP/%{NUMBER:httpversion}" %{NUMBER:response:int} (?:%{NUMBER:bytes:int}|-) "%{DATA:referrer}" "%{DATA:agent}" %{NUMBER:request_time:float}'
      ] }
      tag_on_failure => ["_grokparsefailure_access"]
    }
    date { match => ["timestamp","dd/MMM/YYYY:HH:mm:ss Z"] target => "@timestamp" remove_field => ["timestamp"] }
  }

  if "nginx_error" in [tags] {
    grok {
      match => { "message" => [
        '\[%{LOGLEVEL:level}\] %{NUMBER:pid:int}#%{NUMBER:tid:int}: \*%{NUMBER:conn:int} %{GREEDYDATA:errmsg}, client: %{IPORHOST:client}, server: %{DATA:server}, request: "%{WORD:verb} %{DATA:request} HTTP/%{NUMBER:httpversion}", host: "%{DATA:host}"'
      ] }
      tag_on_failure => ["_grokparsefailure_error"]
    }
    mutate { rename => { "level" => "log.level" } }
  }

  mutate { add_field => { "ingest.source" => "mini-elk" } }
}

output {
  if "nginx_access" in [tags] {
    elasticsearch { hosts => ["http://elasticsearch:9200"] user => "elastic" password => "${ELASTIC_PASSWORD}" index => "nginx_access-%{+YYYY.MM.dd}" }
  }
  if "nginx_error" in [tags] {
    elasticsearch { hosts => ["http://elasticsearch:9200"] user => "elastic" password => "${ELASTIC_PASSWORD}" index => "nginx_error-%{+YYYY.MM.dd}" }
  }
  stdout { codec => rubydebug }
}
